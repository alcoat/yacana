<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
    <title>Yacana - Tool calling</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <link rel="stylesheet" href="../assets/css/main.css"/>
    <link rel="stylesheet" href="../assets/css/codemirror.min.css">
    <link rel="stylesheet" href="../assets/css/monokai.min.css">
    <link rel="stylesheet" href="../assets/css/foldgutter.min.css">
    <link rel="stylesheet" href="../assets/css/codemirror-custom.css">
    <link rel="stylesheet" href="../assets/css/zenburn.min.css">
    <script src="../assets/js/codemirror.min.js"></script>
    <script src="../assets/js/python.min.js"></script>
    <script src="../assets/js/json-lint.min.js"></script>
    <script src="../assets/js/foldcode.min.js"></script>
    <script src="../assets/js/foldgutter.min.js"></script>
    <script src="../assets/js/brace-fold.min.js"></script>
    <script src="../assets/js/codemirror-custom.js"></script>
</head>

<body class="is-preload">

<!-- Wrapper -->
<div id="wrapper">

    <!-- Main -->
    <div id="main">
        <div class="inner">

            <!-- Header -->
            <header id="header">
                <a href="../index.html" class="logo"><strong>Yacana</strong>, powering open source LLMs</a>
                <ul class="icons">
                    <li><a href="https://x.com/RSoftwares_ofc" class="icon brands fa-twitter"><span class="label">Twitter</span></a>
                    </li>
                    <li><a href="https://medium.com/@docteur_rs" class="icon brands fa-medium-m"><span class="label">Medium</span></a>
                    </li>
                    <li><a href="https://www.youtube.com/channel/UCvi7R0CRmtxhWOVw62XteTw"
                           class="icon brands fa-youtube"><span class="label">Medium</span></a></li>
                    <li><a href="https://github.com/rememberSoftwares/yacana" class="icon brands fa-github"><span
                            class="label">Github</span></a></li>
                </ul>
            </header>

            <!-- Content -->
            <section>
                <header class="main">
                    <h1 id="concept-of-calling-tools">V. Tool calling</h1>
                </header>

                <span class="image main"><img src="../images/toolcalling.jpg" alt="Tool calling"/></span>

                <h2>Introduction to the tool calling concept</h2>
                <p>Allowing the LLM to call a tool is the most important thing an agent can do! But what is a
                    "tool"? A tool simply refers to a Python function. This function can be the entry point to any
                    level of underlying complexity. But it doesn't matter. What matters is that the LLM can call the
                    tool with parameters that match the function. This way, LLMs can interact with <em>classic</em>
                    programming interfaces that produce deterministic results (aka normal programming).
                </p>
                <p>For instance, let's say you want a calculator powered by an LLM. You cannot rely on the LLM to do
                    the math because even though it knows how to decompose equations to an extent and has basic
                    arithmetics, it will fail on more advanced calculations. Therefore we do not expect the LLM to
                    perform the operation itself. We already have the CPU to do this task perfectly. On the other
                    hand, we expect the LLM to decompose the equation correctly and call tools for each arithmetic
                    operation needed to solve it.
                </p>
                <br>
                <h4>In what way is Yacana different than other frameworks?</h4>
                <p>Other frameworks assign their tools to the agent during its initialization. This creates a hard
                    link between the tools and the agents. In our opinion, this implementation tends to confuse the
                    agent because it's getting access to many tools that may not be relevant to the immediate task
                    it is given. In Yacana tools are only available at the Task level. Thus no noise is generated
                    before having to solve a particular task. The tool is made available to the LLM only when it's
                    needed and not before. Also, the Agent doesn't keep the memory of the available tools so it
                    won't be tempted to use them elsewhere, where it wouldn't be appropriate.
                </p>
                <br>
                <h4>Understanding the underlying mechanism of tool calling in LLMs</h4>
                <p>A side note for those interested...</p>
                <p>If you don't understand how a text-to-text neural network can call a Python function let me tell
                    you: It doesn't.
                </p><br>
                <p>When we refer to <em>tool calling</em> we also refer to <em>function calling</em> which is very
                    poorly named. Function calling is the ability of an inference server to make the LLM output the
                    text in a particular format. As of today, only JSON is supported but there is no doubt that more
                    formats will be available soon.
                </p><br>
                <p>
                    That said, now that we can control how the LLM answers, we can parse a JSON of which we know the
                    structure. Therefore, we can ask the LLM for a JSON that matches the prototype of a Python
                    function. For instance the function name and some parameter values.
                </p><br>
                <p>
                    Some LLMs have been trained to output JSON in a particular way that matches a particular JSON
                    structure. This particular JSON structure has become a convention and was pushed by big AI
                    players like OpenAI.<br>
                    <br>
                    Unfortunately, the size and complexity of this JSON doesn't work very well with our dumb 8B
                    LLMs. This is a problem that ChatGPT, Claude, Grok and other smart LLMs don't have.<br>
                    To overcome this particular issue, Yacana comes with its own JSON structure to call Python
                    functions! It's way lighter than the OpenAI standard and Yacana uses <a href="https://youtube.com/shorts/Sb1spHDHU_4?si=yZsSLGx-7LeyG-5B">percussive
                        maintenance</a> to force the LLM to output the JSON in a way that the tool
                    expects.
                </p>
                <br>
                <h4>Difference between the OllamaAgent and the OpenAIAgent</h4>
                <p>
                    Tools in Yacana share the same programming API across both Ollama and OpenAI-compatible backends. 
                    However, they currently don't behave identically.<br>
                    The OllamaAgent uses an enhanced tool calling mechanism tailored for local open-source models. 
                    In contrast, the OpenAIAgent uses the standard OpenAI function calling approach, fully compatible with 
                    ChatGPT and any backend that follows OpenAI’s API (like vLLM).<br>
                </p>
                    At the moment, each agent is stuck with its respective mechanism:
                    <ul>
                        <li>The <a href=classes.html#tech-doc-OllamaAgent>OllamaAgent</a> uses the Enhanced Tool Calling</li>
                        <li>The <a href=classes.html#tech-doc-openai-agent>OpenAiAgent</a> uses the OpenAI standard.</li>
                    </ul>
                <p>
                    In the near future, Yacana will support both mechanisms on both agents. The Enhanced Tool Calling 
                    system will be made available to OpenAI-compatible backends, and the OllamaAgent will gain support for the 
                    OpenAI standard via Ollama’s OpenAI-compatible endpoint.<br>
                    Also, note that you can connect the OpenAIAgent to Ollama's OpenAI-compatible endpoint hence
                    using the OpenAI tool calling standard with your Ollama instance.
                </p>

                <hr class="major"/>

                <h2 id="calling-a-tool">Calling a tool</h2>
                <p>Let's write our first tool call to perform a simple addition!</p>
                <p>First, let's define our tool:</p>
                <pre><code class="language-python">
def adder(first_number: int, second_number: int) -> int:
    print(f"Tool adder was called with param {first_number}) ({type(first_number)} and {second_number} ({type(second_number)})")
    return first_number + second_number
					</code></pre>
                <br>
                <p>What do we have here?</p>
                <ul>
                    <li>The name of the function must be relevant to what the function does. Here the function
                        performs an addition so we'll call it <code>adder</code> ;
                    </li>
                    <li>The same thing goes for the parameters. The name you choose is very important as it will
                        help the LLM to know what value to give this parameter ;
                    </li>
                    <li>Duck typing the prototype is very important! You must set the type of each parameter and
                        also the return type of the function ;
                    </li>
                    <li>We perform the operation between the two parameters and return the final result ;</li>
                </ul>
                <p>⚠️ Be aware that whatever the return of your function, Yacana will cast it to string using the
                    built-in <code>str(...)</code> function. LLMs can only understand text so make sure that
                    whatever you send back can be cast correctly (override the <strong>str</strong> if needed).</p>
                <p>Let's create a <a href="classes.html#tech-doc-tool">Tool</a> instance using the Yacana Tool constructor. It takes a
                    name (no space), a description, and a reference to the actual function.<br>
                    <span class="icon solid fa-info-circle"> I can only emphasize once more on the importance of
							providing an accurate description.</span>
                </p>
                <pre><code class="language-python">
adder_tool: Tool = Tool("Adder", "Adds two numbers and returns the result", adder)
					</code></pre>
                <br>
                <p>Now let's assign our <em>adder_tool</em> to a Task. How to do that? It's simple, the Task() class
                    takes an optional <code>tools=[]</code> parameter. It's an array so be sure not to forget those
                    <code>[]</code>!
                </p>
                <pre><code class="language-python">
Task(f"What's 2+2 ?", agent1, tools=[adder_tool]).solve()
					</code></pre>
                <br>
                <p>Full code:</p>
                <pre><code class="language-python">
from yacana import OllamaAgent, Tool, Task

def adder(first_number: int, second_number: int) -> int:
    print(f"Tool adder was called with param {first_number} {type(first_number)} and {second_number} ({type(second_number)})")
    return first_number + second_number

agent1 = OllamaAgent("Ai assistant", "llama3.1:8b")

adder_tool: Tool = Tool("Adder", "Adds two numbers and returns the result", adder)
result: str = Task(f"What's 2+2 ?", agent1, tools=[adder_tool]).solve().content

print("Equation result = ", result)
					</code></pre>
                <br>
                <p>▶️ Output:</p>
                <pre><code class="text-output">
INFO: [PROMPT][To: Ai assistant]: I give you the following tool definition that you must use to fulfill a future task: adder(first_number: int, second_number: int) -&gt; int - Adds two numbers and returns the result. Please acknowledge the given tool.

INFO: [AI_RESPONSE][From: Ai assistant]: Thank you for providing me with the `adder` tool definition! I understand that this is a function that takes two integer arguments (`first_number` and `second_number`) and returns an integer result, which represents the sum of these two input numbers.

I will keep this in mind as we progress through our tasks. Please go ahead and give me the next instruction or task to complete!

INFO: [PROMPT][To: Ai assistant]: To use the tool you MUST extract each parameter and use it as a JSON key like this: {&quot;arg1&quot;: &quot;&lt;value1&gt;&quot;, &quot;arg2&quot;: &quot;&lt;value2&gt;&quot;}. You must respect the arguments type. For instance, the tool `getWeather(city: str, lat: int, long: int)` would be structured like this {&quot;city&quot;: &quot;new-york&quot;, &quot;lat&quot;: 10, &quot;lon&quot;: 20}. In our case, the tool call you must use must look like that: {'first_number': 'arg 0', 'second_number': 'arg 1'}

INFO: [AI_RESPONSE][From: Ai assistant]: Thank you for clarifying how to structure the tool calls.

In that case, I will extract each parameter and use it as a JSON key. For the `adder` tool, I will structure the tool call as follows:

{'first_number': 3, 'second_number': 5}

Please let me know what's next!

INFO: [PROMPT][To: Ai assistant]: You have a task to solve. Use the tool at your disposition to solve the task by outputting as JSON the correct arguments. In return you will get an answer from the tool. The task is:
What's 2+2 ?

INFO: [AI_RESPONSE][From: Ai assistant]: {&quot;first_number&quot;: &quot;2&quot;, &quot;second_number&quot;: &quot;2&quot;}

Tool adder was called with param '2' (&lt;class 'str'&gt;) and '2' (&lt;class 'str'&gt;)
Equation result =  22
					</code></pre>
                <br>
                <p>The multiple INFO logs you are seeing here is Yacana doing its magic to make the LLM call the
                    tool.</p>
                <p>Unfortunately, even though the tool is indeed called, getting a correct result failed
                    spectacularly! ^^<br>
                    Is <code>2 + 2 = 22</code>? No, I don't think so. Can you find out what went wrong?</p>
                <hr>
                <p>When looking at the logs we can see that the tool was called with the following JSON:
                    <code>{"first_number": "2", "second_number": "2"}</code>. The values are of type
                    <code>string</code>. Later confirmed by the <code>print()</code> inside the tool itself:
                    <code>param '2' ('str') and '2' ('str')</code>.<br>
                    So instead of having integers, we got strings and what's the result of <code>"2" + "2"</code> in
                    Python?<br>
                    Not <i>"4"</i> but <i>"22"</i> (concatenation of strings). Bummer! ^^
                </p>
                <p>Fortunately, we can fix this easily in several ways.</p>

                <hr class="major"/>

                <h2 id="improving-tool-calling-results">Improving tool-calling results</h2>
                <p>
                    As you saw in the previous adder example we ran into trouble with the <code>2 + 2</code> call
                    sent as a string. Let's fix that.
                </p>
                <br>

                <h4>Adding validation inside the Tool</h4>

                <p>
                    Since LLMs are not deterministic, we can never be certain of the values they’ll send to our tools. 
                    That’s why you should think of a tool the same way you would a web server route—it requires server-side validation. 
                    Your tool must verify the input it receives and raise an error if the data is invalid.
                </p>
                <p>
                    This involves adding strict validation checks to your tool. 
                    When the LLM sends an incorrect value, an error will be raised, not just any error, but a ToolError(...). 
                    Yacana will catch this exception and notify the LLM that something went wrong during the tool call.<br>
                    It’s crucial to provide clear and specific error messages in the exception, as the LLM will use that message to adjust its next attempt.
                </p>
                <p>Let's upgrade our adder tool!</p>
                <pre><code class="language-python">
from yacana import OllamaAgent, Tool, Task, ToolError


def adder(first_number: int, second_number: int) -> int:
    print(f"Tool adder was called with param {first_number} {type(first_number)} and {second_number} ({type(second_number)})")
    # Adding type validation
    if not (isinstance(first_number, int)):
        raise ToolError("Parameter 'first_number' expected a type integer")
    if not (isinstance(second_number, int)):
        raise ToolError("Parameter 'second_number' expected a type integer")
					</code></pre>
                <br>
                <p>
                    We added type validation on both parameters. But you should also check for None values, etc. As I
                    said. Think of this as server-side validation. You cannot trust AI more than humans...
                </p>
                <p>
                    Let's remove the "examples" set in the previous section. The LLM will be blind once again. As
                    such, he will probably make mistakes but the ToolError exception will guide it onto the correct
                    path. Let's see:
                </p>
                <br>
                <p><em>Complete code</em></p>
                <pre><code class="language-python">
from yacana import OllamaAgent, Tool, Task, ToolError

agent1 = OllamaAgent("Ai assistant", "llama3.1:8b")

def adder(first_number: int, second_number: int) -> int:
    print(f"Tool adder was called with param '{first_number}' ({type(first_number)}) and '{second_number}' ({type(second_number)})")
    if not (isinstance(first_number, int)):
        raise ToolError("Parameter 'first_number' expected a type integer")
    if not (isinstance(second_number, int)):
        raise ToolError("Parameter 'second_number' expected a type integer")
    ret = first_number + second_number
    print("Result of added tool is: ", ret)
    return ret

# No more examples
adder_tool: Tool = Tool("Adder", "Adds two numbers and returns the result", adder)

result: str = Task(f"What's 2+2 ?", agent1, tools=[adder_tool]).solve().content

print(f"Equation result = {result}")
					</code></pre>
                <br>
                <p>▶️ Output:</p>
                <pre><code class="text-output">
INFO: [PROMPT][To: Ai assistant]: I give you the following tool definition that you must use to fulfill a future task: adder(first_number: int, second_number: int) -> int - Adds two numbers and returns the result. Please acknowledge the given tool.

INFO: [AI_RESPONSE][From: Ai assistant]: Acknowledged!

I have taken note of the `adder` tool definition:

`adder(first_number: int, second_number: int) -> int`

This tool takes two integer arguments, `first_number` and `second_number`, and returns their sum as an integer.

I'm ready to use this tool when needed.

INFO: [PROMPT][To: Ai assistant]: To use the tool you MUST extract each parameter and use it as a JSON key like this: {"arg1": "&#60;value1&#62;", "arg2": "&#60;value2&#62;"}. You must respect argument type. For instance, the tool `getWeather(city: str, lat: int, long: int)` would be structured like this {"city": "new-york", "lat": 10, "lon": 20}. In our case, the tool call you must use must look like that: {'first_number': 'arg 0', 'second_number': 'arg 1'}

INFO: [AI_RESPONSE][From: Ai assistant]: Thank you for the clarification.

For the `adder` tool, I will extract each parameter and use it as a JSON key. Here is the result:

{"first__number": "arg 0", "second__number": "arg 1"}

I will make sure to respect the argument types (in this case, both are integers) when using this structure in the future.

Thank you for the guidance!

INFO: [PROMPT][To: Ai assistant]: You have a task to solve. Use the tool at your disposition to solve the task by outputting as JSON the correct arguments. In return, you will get an answer from the tool. The task is:
What's 2+2 ?

INFO: [AI_RESPONSE][From: Ai assistant]: {"first__number": 2, "second__number": 2}

WARNING: Yacana failed to call tool 'Adder' correctly based on the LLM output


INFO: [PROMPT][To: Ai assistant]: The tool returned an error: `adder() got an unexpected keyword argument 'first__number'`
Using this error message, fix the JSON arguments you gave.
Remember that you must output ONLY the tool arguments as valid JSON. For instance: {'first_number': 'arg 0', 'second_number': 'arg 1'}

INFO: [AI_RESPONSE][From: Ai assistant]: {"first_number": "arg 0", "second_number": "arg 1"}
Tool adder was called with param 'arg 0' (&#60;class 'str'&#62;) and 'arg 1' (&#60;class 'str'&#62;)

WARNING: Tool 'Adder' raised an error


INFO: [PROMPT][To: Ai assistant]: The tool returned an error: `Parameter 'first_number' expected a type integer`
Using this error message, fix the JSON arguments you gave.


INFO: [AI_RESPONSE][From: Ai assistant]: {"first_number": 2, "second_number": 2}
Tool adder was called with param '2' (&#60;class 'int'&#62;) and '2' (&#60;class 'int'&#62;)
Result of added tool is:  4
Equation result = 4
					</code></pre>
                <br>
                <p>It worked!</p>
                <p>2 warnings happened here:</p>
                <ul>
                    <li><i>"WARNING: Yacana failed to call tool 'Adder' correctly based on the LLM output"</i></li>
                    <li><i>"WARNING: Tool 'Adder' raised an error"</i></li>
                </ul>
                <ul>
                    <li><strong>Warning 1</strong>: Regarding the first one if you look closely at the output you
                        can
                        see a strange malformation in the JSON:
                        <code>{"first__number": "arg 0", "second__number": "arg 1"}</code>. The first parameter was
                        called with two underscores for some reason (LLMs...). Fortunately, Yacana banged on the
                        LLM's head and it was fixed in the next iteration.
                    </li>
                    <li><strong>Warning 2</strong>: Concerning the second warning, it was the tool itself that
                        raised
                        the exception:
                        <code>The tool returned an error: Parameter 'first_number' expected a type integer</code>.
                        This is only logical as the LLM sent catastrophic values to the tool:
                        <code>{'first_number': 'arg 0', 'second_number': 'arg 1'}</code>. When the ToolError was
                        raised the error message was given to the LLM and a third iteration started. This time all
                        was correct: <code>{"first_number": 2, "second_number": 2}</code> and we got our result from
                        the tool which is 4.
                    </li>
                </ul>

                <h4>Providing tool call examples</h4>
                <p>
                    If you followed this tutorial from the start, you saw that multi-shot prompting can sometime help getting more accurate outputs. 
                    The Tool class allows this too, using the <code>usage_examples=[]</code> optional
                    parameter. You can provide a Python dictionary where each key corresponds to a function's
                    parameter and the value, a valid value. It's inside an array so you can provide multiple
                    examples if needed. In general one or two is enough.<br>
                    These dictionaries will be presented by Yacana to the LLM as examples of how to call the tool
                    correctly.</p>
                <p>Let's look at an example with this new tool instance:</p>
                <pre><code class="language-python">
adder_tool: Tool = Tool("Adder", "Adds two numbers and returns the result", adder, usage_examples=[{"first_number": 2, "second_number": 4}, {"first_number": 8, "second_number": -2}])
					</code></pre>
                <br>
                <p>We provided above two examples for the LLM to look at. Each time giving <code>first_number</code>
                    and <code>second_number</code> different integer values. No strings. Actual integers!</p>
                <p>Let's run our program again and see if we get the correct input types this time:</p>
                <pre><code class="text-output">
INFO: [PROMPT][To: Ai assistant]: I give you the following tool definition that you must use to fulfill a future task: adder(first_number: int, second_number: int) -> int - Adds two numbers and returns the result. Please acknowledge the given tool.

INFO: [AI_RESPONSE][From: Ai assistant]: Acknowledged!

The tool definition provided is:

`adder(first_number: int, second_number: int) -> int`

This tool takes two integer inputs `first_number` and `second_number`, and returns their sum as an integer.

I'm ready to use this tool for any future tasks that require addition!

INFO: [PROMPT][To: Ai assistant]: To use the tool you MUST extract each parameter and use it as a JSON key like this: {"arg1": "<value1>", "arg2": "<value2>"}. You must respect the arguments type. For instance, the tool `getWeather(city: str, lat: int, long: int)` would be structured like this {"city": "new-york", "lat": 10, "lon": 20}. In our case, the tool call you must use must look like that: {'first_number': 'arg 0', 'second_number': 'arg 1'}

INFO: [AI_RESPONSE][From: Ai assistant]: I understand now!

So, for the `adder` tool, I need to extract each parameter and structure it as a JSON key-value pair. Here's the result:

{'first_number': 'int', 'second_number': 'int'}

This means that when using this tool, I should specify two integer values for `first_number` and `second_number`, respectively.

INFO: [PROMPT][To: Ai assistant]: You have a task to solve. Use the tool at your disposition to solve the task by outputting as JSON the correct arguments. In return, you will get an answer from the tool. The task is:
What's 2+2 ?

INFO: [AI_RESPONSE][From: Ai assistant]: {"first_number": 2, "second_number": 2}

Tool adder was called with param '2' (<class 'int'>) and '2' (<class 'int'>)
Equation result =  4
				</code></pre>
                <br>
                <p>It worked!<br>
                    The LLM saw that the tool needed integers for input. As such, it called the tool with the correct
                    types therefore the adder tool returned <code>4</code> as it was expected. Houra!</p>
                <p>⚠️ Do not abuse this technic as it tends to create some noise. Trying to manage too many
                    hypothetical use cases might, in the end, degrade the performance of the tool call.</p>
                <p class="icon solid fa-info-circle">
                    You should combine both server-side validaton and multi-shot prompting.<br>
                    Providing one example may prevent one tool call failure hence less lost CPU time.
                    Though, adding many validation checks in your tool raising with explicit
                    error messages is the best way to ensure that nothing breaks! Nothing beats good all fashion
                    <code>if</code> checks!
                </p>


                <h4>Maximum tool errors</h4>
                <p>What happens if the LLM is stubborn and gets stuck in a loop? Even though Yacana's percussive
                    maintenance should avoid that by shifting LLM internal configuration during runtime more or less
                    randomly, the LLM still might go into an infinite loop. And this is NOT a viable option!<br>
                    Fortunately, Yacana comes with a default of 5 iterations (tries) for each of the 2 types of
                    errors we encountered earlier:</p>
                <ul>
                    <li>Either the calling error like the <code>"first__number"</code> error seen above.</li>
                    <li>Or the custom ToolError that the tool threw.
                        This means that if one of these two counters gets to 5 then an error is raised. One that is
                        not caught by Yacana.<br>
                        Specifically a <code>MaxToolErrorIter</code> exception. You should try/catch all of your
                        Tasks that utilize Tools as they might loop too many times and trigger this exception.
                    </li>
                </ul>
                <p>However, you can also set these counters to the value you wish... Move them higher or lower with
                    the following Tool optional parameters:
                    <code> max_call_error: int = 5, max_custom_error: int = 5</code>
                    For instance:
                </p>
                <pre><code class="language-python">
# Doubling the number of iterations the LLM can do before raising `MaxToolErrorIter`: 5 -> 10
adder_tool: Tool = Tool("Adder", "Adds two numbers and returns the result", adder, max_custom_error=10, max_call_error=10)
					</code></pre>
                <br>

                <hr class="major"/>

                <h2 id="optional-tools">Optional tools</h2>
                <p>Sometimes you assign a Tool to a Task without knowing for sure that the tool will be useful. If
                    you have a fine-tuned model or doing basic operations you may want to rely on the LLM's
                    reasoning to choose if it really needs to call the tool or use his own training knowledge.
                    Setting the <code>optional: bool = True</code> will tweak how Yacana proposes the Tools to the
                    LLM, leaving it a chance to pass on the offer of the tool and use its own knowledge instead.</p>
                <p>To demonstrate this, let's make a tool that returns a temperature from a city. It will return a
                    fake temperature as we don't really care. We <strong>won't</strong> set
                    <code>optionnal=True</code> so it will be forced to use the tool:
                </p>
                <pre><code class="language-python">
from yacana import Task, OllamaAgent, Tool

def get_temperature(city: str) -> int:
    return 20

agent1 = OllamaAgent("Ai assistant", "llama3.1:8b")

result: str = Task(f"What's the temperature in NY ?", agent1, tools=[Tool("get_temp", "Returns the celsius temperature of a given city", get_temperature)]).solve().content

print(f"Temperature = {result}")						
					</code></pre>
                <br>
                <p>▶️ Output:</p>
                <pre><code class="text-output">
INFO: [PROMPT][To: Ai assistant]: I give you the following tool definition that you must use to fulfill a future task: get_temperature(city: str) -> int - Adds two numbers and returns the result. Please acknowledge the given tool.

INFO: [AI_RESPONSE][From: Ai assistant]: I've received the tool definition!

So, I understand that I have been given a tool called `get_temperature` that takes one argument `city` which is a string, and it's supposed to return an integer.

However, I notice that the tool definition says "Adds two numbers and returns the result" but the function name `get_temperature` suggests it should be related to getting the temperature of a city.

I'll make sure to keep this in mind for any future tasks that require using this tool!

INFO: [PROMPT][To: Ai assistant]: To use the tool you MUST extract each parameter and use it as a JSON key like this: {"arg1": "<value1>", "arg2": "<value2>"}. You must respect arguments type. For instance, the tool `getWeather(city: str, lat: int, long: int)` would be structured like this {"city": "new-york", "lat": 10, "lon": 20}. In our case, the tool call you must use must look like that: {'city': 'arg 0'}

INFO: [AI_RESPONSE][From: Ai assistant]: So I understand now. Thank you for the clarification!

To use the `get_temperature` tool, I will extract each parameter and use it as a JSON key with its corresponding value.

The tool definition is: `get_temperature(city: str) -> int`

So, I will structure my tool call like this:  {"city": "arg0"}

Please let me know what's the next step!

INFO: [PROMPT][To: Ai assistant]: You have a task to solve. Use the tool at your disposition to solve the task by outputting as JSON the correct arguments. In return you will get an answer from the tool. The task is:
What's the temperature in NY ?

INFO: [AI_RESPONSE][From: Ai assistant]: { "city": "NY" }
Temperature = 20			
					</code></pre>
                <br>
                <p>The tool was called with <code>{ "city": "NY" }</code> which returned 20. Good!</p>
                <hr>
                <p>Now let's ask something completely unrelated but keep the tool mandatory:</p>
                <pre><code class="language-python">
result: str = Task(f"Why is the sky blue ?", agent1, tools=[Tool("get_temp", "Returns the celsius temperature of a given city", get_temperature)]).solve().content					
					</code></pre>
                <br>
                <p>▶️ Output:</p>
                <pre><code class="text-output">
INFO: [PROMPT][To: Ai assistant]: I give you the following tool definition that you must use to fulfill a future task: get_temperature(city: str) -> int - Returns the celsius temperature of a given city. Please acknowledge the given tool.

INFO: [AI_RESPONSE][From: Ai assistant]: Acknowledged!

You've provided me with a tool definition for `get_temperature(city: str) -> int`, which returns the Celsius temperature of a given city.

I'm ready to use this tool whenever I need it in future tasks!

INFO: [PROMPT][To: Ai assistant]: To use the tool you MUST extract each parameter and use it as a JSON key like this: {"arg1": "<value1>", "arg2": "<value2>"}. You must respect the arguments type. For instance, the tool `getWeather(city: str, lat: int, long: int)` would be structured like this {"city": "new-york", "lat": 10, "lon": 20}. In our case, the tool call you must use must look like that: {'city': 'arg 0'}

INFO: [AI_RESPONSE][From: Ai assistant]: For the `get_temperature( city: str ) -> int` tool, I understand that I need to extract each parameter and use it as a JSON key.

So, for this specific tool, I would structure my JSON call as follows:

{"city": "arg0"}

Where "arg0" is replaced with the actual value of the city I'm interested in.

INFO: [PROMPT][To: Ai assistant]: You have a task to solve. Use the tool at your disposition to solve the task by outputting as JSON the correct arguments. In return you will get an answer from the tool. The task is:
Why is the sky blue ?

INFO: [AI_RESPONSE][From: Ai assistant]: {"city": "Paris"}
Temperature = 20
					</code></pre>
                <br>
                <p>It asked the tool for the temperature in the city 'Paris' without any particular reason. We can't
                    blame it. The tool we provided and the Task to solve have nothing to do with each other. So it's
                    making things up, like this city name.</p>
                <hr>
                <p>Now let's make the tool optional with <code>optional=True</code> and keep our unrelated Task:</p>
                <pre><code class="language-python">
result: str = Task(f"Why is the sky blue ?", agent1, tools=[Tool("get_temp", "Returns the celsius temperature of a given city", get_temperature, optional=True)]).solve().content						
					</code></pre>
                <br>
                <p>▶️ Output:</p>
                <pre><code class="text-output">
INFO: [PROMPT][To: Ai assistant]: I give you the following tool definition that you may use to fulfill a future task: get_temperature(city: str) -> int - Returns the celsius temperature of a given city. Please acknowledge the given tool.

INFO: [AI_RESPONSE][From: Ai assistant]: Acknowledged!

I have taken note of the `get_temperature` tool, which takes a city name as input (`city: str`) and returns the Celsius temperature of that city (`-> int`). I'm ready to use this tool whenever you'd like me to fulfill a task in the future!

INFO: [PROMPT][To: Ai assistant]: To use the tool you MUST extract each parameter and use it as a JSON key like this: {"arg1": "<value1>", "arg2": "<value2>"}. You must respect arguments type. For instance, the tool `getWeather(city: str, lat: int, long: int)` would be structured like this {"city": "new-york", "lat": 10, "lon": 20}. In our case, the tool call you must use must look like that: {'city': 'arg 0'}

INFO: [AI_RESPONSE][From: Ai assistant]: So for the `get_temperature( city: str )` tool, I would extract the single parameter as:

{"city": "arg0"}

Please let me know what's next!

INFO: [PROMPT][To: Ai assistant]: You have a task to solve. In your opinion, is using the tool "get_temp" relevant to solve the task or not ? The task is:
Why is the sky blue ?

INFO: [AI_RESPONSE][From: Ai assistant]: Ha ha, that's an interesting question!

In my opinion, using the `get_temperature` tool is NOT relevant to solving this task. The task asks about why the sky is blue, and temperature doesn't seem to be directly related to that.

So, I'll have to come up with a different approach or use a different tool (if one exists) to tackle this question!

INFO: [PROMPT][To: Ai assistant]: To summarize in one word your previous answer. Do you wish to use the tool or not ? Respond ONLY by 'yes' or 'no'.

INFO: [AI_RESPONSE][From: Ai assistant]: no

INFO: [PROMPT][To: Ai assistant]: Why is the sky blue ?

INFO: [AI_RESPONSE][From: Ai assistant]: A question that has puzzled humans for centuries!

The sky appears blue because of a phenomenon called Rayleigh scattering, named after the British physicist Lord Rayleigh. Here's what happens:

1. **Sunlight**: The sun emits white light, which is made up of all the colors of the visible spectrum (red, orange, yellow, green, blue, indigo, and violet).
2. **Atmosphere**: When this sunlight enters Earth's atmosphere, it encounters tiny molecules of gases like nitrogen (N2) and oxygen (O2). These molecules are much smaller than the wavelength of light.
[BLABLA]
5. **Sky appears blue**: The combined effect of all these scattered blue and violet photons is what makes the sky appear blue to our eyes! The more direct sunlight that reaches our eyes, the whiter it will appear.

So, to summarize: the sky appears blue because of the selective scattering of shorter wavelengths (like blue and violet) by tiny molecules in the atmosphere, which dominates the colors we see when looking up at the sky.
                </code></pre>
                <br>
                <p>As you can see it chose to ignore the tool when Yacana proposed it. It said:</p>
                <pre><code class="text-output">
						In my opinion, using the `get_temperature` tool is NOT relevant to solving this task. The task asks about why the sky is blue, and temperature doesn't seem to be directly related to that.
					</code></pre>
                <br>

                <hr class="major"/>

                <h2 id="assigning-multiple-tools">Assigning multiple Tools</h2>
                <p>In this section, we will see that you can assign more than one tool to a Task. You can add as
                    many Tools as you wish and the LLM will be asked what tool it wants to use. After using one of
                    the tools it will be asked if it considers its Task complete. If it says "no" then Yacana will
                    propose the list of tools again and a new iteration starts.</p>
                <p>This is roughly what the tool-calling mechanism looks like:<br>
                    <span class="image main"><img
                            src="https://github.com/user-attachments/assets/bfaec298-44e9-4177-bfb8-e25bdfd01fe6"
                            alt="toolcall1B"></span>
                </p>
                <p class="icon solid fa-info-circle">
                    This doesn't take into account many tweaks Yacana makes like model's runtime config updates
                    (in case of infinite loops), optional tools, self-reflection, multi-shot tool call examples,
                    history cleaning, exiting when reaching max iterations, etc. However, it's a good representation 
                    of the internal process of calling tools one after the other.
                </p>
                <p><em>Additional behavior information:</em></p>
                <blockquote>
                    <p>When only one tool is assigned, the Agent won't be proposed to use it again. One tool is one
                        shot!
                        When giving multiple tools, the agent will then be proposed to use another tool. He could
                        choose to always use the same one though.<br>
                        In the future, Yacana may allow you to have more control over how the tools are being
                        chosen.
                    </p>
                </blockquote>
                <p>⚠️ For this next section we assume that you have already read section <strong>Assigning a tool to
                    a Task</strong> of the documentation.</p>
                <p>Let's make a more advanced calculator and solve <code>2 + 2 - 6 * 8</code>. We'll add the missing
                    tools and give them some
                    "server-side" checking to help the LLM use them properly.</p>
                <pre><code class="language-python">
from yacana import Task, OllamaAgent, Tool, ToolError

def adder(first_number: int, second_number: int) -> int:
    print("Adder was called with types = ", str(type(first_number)), str(type(second_number)))
    if not (isinstance(first_number, int)):
        raise ToolError("Parameter 'first_number' expected a type integer")
    if not (isinstance(second_number, int)):
        raise ToolError("Parameter 'second_number' expected a type integer")
    print(f"Adder was called with param = |{first_number}| and |{second_number}|")
    return first_number + second_number

def multiplier(first_number, second_number) -> int:
    print("Multiplier was called with types = ", str(type(first_number)), str(type(second_number)))
    if not (isinstance(first_number, int)):
        raise ToolError("Parameter 'first_number' expected a type integer")
    if not (isinstance(second_number, int)):
        raise ToolError("Parameter 'second_number' expected a type integer")
    print(f"Multiplier was called with param = |{first_number}| and |{second_number}|")
    return first_number * second_number

def substractor(first_number, second_number) -> int:
    print("substractor was called with types = ", str(type(first_number)), str(type(second_number)))
    if not (isinstance(first_number, int)):
        raise ToolError("Parameter 'first_number' expected a type integer")
    if not (isinstance(second_number, int)):
        raise ToolError("Parameter 'second_number' expected a type integer")
    print(f"substractor was called with param = |{first_number}| and |{second_number}|")
    return first_number - second_number



agent1 = OllamaAgent("Ai assistant", "llama3.1:8b")

# Defining 3 tools
adder_tool: Tool = Tool("Adder", "Adds two numbers and returns the result", adder)
substractor_tool: Tool = Tool("Substractor", "Subtracts two numbers and returns the result. When having, for instance, 2 - 6 the arguments are 2 and 6 and not 2 and -6. The tool does the subtraction.", substractor, usage_examples=[{"first_number": 2, "second_number": 4}])
multiplier_tool: Tool = Tool("Multiplier", "Multiplies two numbers and returns the result.", multiplier)

# Creating a Task to solve and assigning tools to it
result: str = Task(
    f"What's the result of '2 + 2 - 6 * 8'. Decompose the math before trying to solve it. Start with the multiplication. Use the tools at your disposal and do not do the maths yourself.",
    agent1, tools=[
        adder_tool,
        substractor_tool,
        multiplier_tool
    ]).solve().content


print("Result = ", result)
					</code></pre>
                <br>
                <p>▶️ Output:</p>
                <pre><code class="text-output">
INFO: [PROMPT][To: Ai assistant]: You have access to this list of tools definitions you can use to fulfill tasks :
* Name: 'Adder' - Usage: adder(first_number: int, second_number: int) -> int - Description: Adds two numbers and returns the result
* Name: 'Substractor' - Usage: substractor(first_number, second_number) -> int - Description: Subtracts two numbers and returns the result. When having, for instance, 2 - 6 the arguments are 2 and 6 and not 2 and -6. The tool does the subtraction.
* Name: 'Multiplier' - Usage: multiplier(first_number, second_number) -> int - Description: Multiplies two numbers and returns the result.
Please acknowledge the given tools.

INFO: [AI_RESPONSE][From: Ai assistant]: I have access to the following tools:

1. **Adder**: Adds two numbers together and returns the result.
        * Usage: `adder(first_number: int, second_number: int) -> int`
2. **Substractor**: Subtracts one number from another (regardless of order) and returns the result.
        * Usage: `substractor(first_number, second_number) -> int`
3. **Multiplier**: Multiplies two numbers together and returns the result.
        * Usage: `multiplier(first_number, second_number) -> int`

I'm ready to use these tools to perform mathematical operations!

INFO: [PROMPT][To: Ai assistant]: You have a task to solve. I will give it to you between these tags `&#60;task&#62;&#60;/task&#62;`. However, your actual job is to decide if you need to use any of the available tools to solve the task or not. If you do need tools then output their names. The task to solve is &#60;task&#62;What's the result of '2 + 2 - 6 * 8'. Decompose the math before trying to solve it. Start with the multiplication. Use the tools at your disposal and do not do the maths yourself.&#60;/task&#62; So, would any tools be useful in relation to the given task ?

INFO: [AI_RESPONSE][From: Ai assistant]: To decompose the math expression '2 + 2 - 6 * 8', I need to follow the order of operations (PEMDAS/BODMAS). According to this rule, multiplication should be done before addition and subtraction.

So, the first step is to calculate the result of `6 * 8`. This requires using the **Multiplier** tool.

INFO: [PROMPT][To: Ai assistant]: In order to summarize your previous answer in one word. Did you chose to use any tools ? Respond ONLY by 'yes' or 'no'.

INFO: [AI_RESPONSE][From: Ai assistant]: Yes.

INFO: [PROMPT][To: Ai assistant]: You can only use one tool at a time. From this list of tools which one do you want to use: [Adder, Substractor, Multiplier]. You must answer ONLY with the single tool name. Nothing else.

INFO: [AI_RESPONSE][From: Ai assistant]: Yes
Multiplier

WARNING: Tool choice was not an exact match but a substring match


INFO: [PROMPT][To: Ai assistant]: To use the tool you MUST extract each parameter and use it as a JSON key like this: {"arg1": "&#60;value1&#62;", "arg2": "&#60;value2&#62;"}. You must respect arguments type. For instance, the tool `getWeather(city: str, lat: int, long: int)` would be structured like this {"city": "new-york", "lat": 10, "lon": 20}. In our case, the tool call you must use must look like that: {'first_number': 'arg 0', 'second_number': 'arg 1'}

INFO: [AI_RESPONSE][From: Ai assistant]: {'first_number': '6', 'second_number': '8'}

INFO: [PROMPT][To: Ai assistant]: Now that I showed you examples on how the tool is used it's your turn. Output the tool as valid JSON.

INFO: [AI_RESPONSE][From: Ai assistant]: {"first_number": "6", "second_number": "8"}
Multiplier was called with types =  &#60;class 'str'&#62; &#60;class 'str'&#62;

WARNING: Tool 'Multiplier' raised an error


INFO: [PROMPT][To: Ai assistant]: The tool returned an error: `Parameter 'first_number' expected a type integer`
Using this error message, fix the JSON arguments you gave.


INFO: [AI_RESPONSE][From: Ai assistant]: {"arg1": 6, "arg2": 8}

WARNING: Yacana failed to call tool 'Multiplier' correctly based on the LLM output


INFO: [PROMPT][To: Ai assistant]: The tool returned an error: `multiplier() got an unexpected keyword argument 'arg1'`
Using this error message, fix the JSON arguments you gave.
Remember that you must output ONLY the tool arguments as valid JSON. For instance: {'first_number': 'arg 0', 'second_number': 'arg 1'}

INFO: [AI_RESPONSE][From: Ai assistant]: {"first_number": 6, "second_number": 8}
Multiplier was called with types =  &#60;class 'int'&#62; &#60;class 'int'&#62;
Multiplier was called with param = |6| and |8|

INFO: [TOOL_RESPONSE][Multiplier]: 48


INFO: [PROMPT][To: Ai assistant]: Now that the tool responded do you need to make another tool call ? Explain why and what are the remaining steps are if any.

INFO: [AI_RESPONSE][From: Ai assistant]: The result of `6 * 8` is 48.

Next, I need to calculate the result of `2 + 2 - 48`. To do this, I need to use the **Adder** tool to add `2 + 2`, and then use the **Substractor** tool to subtract the result from the multiplication (`48`) from the sum.

INFO: [PROMPT][To: Ai assistant]: To summarize your previous answer in one word. Do you need to make another tool call ? Answer ONLY by 'yes' or 'no'.

INFO: [AI_RESPONSE][From: Ai assistant]: Yes

INFO: Continuing tool calls loop


INFO: [PROMPT][To: Ai assistant]: You can only use one tool at a time. From this list of tools which one do you want to use: [Adder, Substractor, Multiplier]. You must answer ONLY with the single tool name. Nothing else.

INFO: [AI_RESPONSE][From: Ai assistant]: Yes
Adder

WARNING: Tool choice was not an exact match but a substring match


INFO: [PROMPT][To: Ai assistant]: To use the tool you MUST extract each parameter and use it as a JSON key like this: {"arg1": "&#60;value1&#62;", "arg2": "&#60;value2&#62;"}. You must respect arguments type. For instance, the tool `getWeather(city: str, lat: int, long: int)` would be structured like this {"city": "new-york", "lat": 10, "lon": 20}. In our case, the tool call you must use must look like that: {'first_number': 'arg 0', 'second_number': 'arg 1'}

INFO: [AI_RESPONSE][From: Ai assistant]: {"first_number": 2, "second_number": 2}

INFO: [PROMPT][To: Ai assistant]: Now that I showed you examples on how the tool is used it's your turn. Output the tool as valid JSON.

INFO: [AI_RESPONSE][From: Ai assistant]: {"first_number": 48, "second_number": -46}
Adder was called with types =  &#60;class 'int'&#62; &#60;class 'int'&#62;
Adder was called with param = |48| and |-46|

INFO: [TOOL_RESPONSE][Adder]: 2


INFO: [PROMPT][To: Ai assistant]: Now that the tool responded do you need to make another tool call ? Explain why and what are the remaining steps are if any.

INFO: [AI_RESPONSE][From: Ai assistant]: The result of `2 + 2` is indeed 4.

Next, I still need to subtract 48 from this result (4) using the **Substractor** tool.

So, yes, I need another tool call. The remaining step is to use the **Substractor** tool with arguments `(4, 48)`.

INFO: [PROMPT][To: Ai assistant]: To summarize your previous answer in one word. Do you need to make another tool call ? Answer ONLY by 'yes' or 'no'.

INFO: [AI_RESPONSE][From: Ai assistant]: Yes
Substractor

INFO: Continuing tool calls loop


INFO: [PROMPT][To: Ai assistant]: You can only use one tool at a time. From this list of tools which one do you want to use: [Adder, Substractor, Multiplier]. You must answer ONLY with the single tool name. Nothing else.

INFO: [AI_RESPONSE][From: Ai assistant]: Yes
Substractor

WARNING: Tool choice was not an exact match but a substring match


INFO: [PROMPT][To: Ai assistant]: To use the tool you MUST extract each parameter and use it as a JSON key like this: {"arg1": "&#60;value1&#62;", "arg2": "&#60;value2&#62;"}. You must respect arguments type. For instance, the tool `getWeather(city: str, lat: int, long: int)` would be structured like this {"city": "new-york", "lat": 10, "lon": 20}. In our case, the tool call you must use must look like that: {'first_number': 'arg 0', 'second_number': 'arg 1'}

INFO: [AI_RESPONSE][From: Ai assistant]: {"first_number": 4, "second_number": 48}

INFO: [PROMPT][To: Ai assistant]: Now that I showed you examples on how the tool is used it's your turn. Output the tool as valid JSON.

INFO: [AI_RESPONSE][From: Ai assistant]: {"first_number": 4, "second_number": 48}
substractor was called with types =  &#60;class 'int'&#62; &#60;class 'int'&#62;
substractor was called with param = |4| and |48|

INFO: [TOOL_RESPONSE][Substractor]: -44


INFO: [PROMPT][To: Ai assistant]: Now that the tool responded do you need to make another tool call ? Explain why and what are the remaining steps are if any.

INFO: [AI_RESPONSE][From: Ai assistant]: The result of `2 + 2 - 6 * 8` is indeed `-44`.

Since I have now calculated all parts of the original expression, there are no more remaining steps or tool calls needed. The task is complete!

INFO: [PROMPT][To: Ai assistant]: To summarize your previous answer in one word. Do you need to make another tool call ? Answer ONLY by 'yes' or 'no'.

INFO: [AI_RESPONSE][From: Ai assistant]: no

INFO: Exiting tool calls loop

Result =  The result of `2 + 2 - 6 * 8` is indeed `-44`.

Since I have now calculated all parts of the original expression, there are no more remaining steps or tool calls needed. The task is complete!

					</code></pre>
                <br>
                <p>
                    -44 is the correct answer!
                </p>
                <div style="text-align: center; margin-top: 50px;">
                    <h4>Pagination</h4>
                    <ul class="pagination">
                        <li><a href="managing_agent_history.html#printing-history" class="button">Prev</a></li>

                        <li><a href="agents_features.html"
                               class="button">Next</a></li>
                    </ul>
                </div>
            </section>
        </div>
    </div>

    <!-- Sidebar -->
    <div id="sidebar">
        <div class="inner">

            <!-- Search -->
            <section id="search" class="alt">
                <form method="post" action="#">
                    <input type="text" name="query" id="query" placeholder="Search"/>
                </form>
            </section>

            <!-- Menu Container -->
            <div id="menu-container"></div>

            <!-- Section -->
            <section>
                <div class="page-nav-container">
                    <!-- Dynamic page navigation will be inserted here -->
                </div>
            </section>

            <!-- Section -->
            <section>
                <header class="major">
                    <h2>Related Youtube video</h2>
                </header>
                <div class="mini-posts">
                    <article>
                        <a href="#" class="image"><img src="../images/youtube_down.jpg" alt=""/></a>
                        <p>Youtube video for this section is still under creation. Please be patient ^^</p>
                    </article>
                </div>
            </section>

            <!-- Footer -->
            <footer id="footer">
                <p class="copyright">&copy; Emilien Lancelot. All rights reserved.<br>
                    Design: <a href="https://html5up.net">HTML5UP</a>.</p>
            </footer>

        </div>
    </div>

</div>

<!-- Scripts -->
<script src="../assets/js/jquery.min.js"></script>
<script src="../assets/js/browser.min.js"></script>
<script src="../assets/js/breakpoints.min.js"></script>
<script src="../assets/js/util.js"></script>
<script src="../assets/js/main.js"></script>
<script src="../assets/js/menu.js"></script>
<script>
    // Initialize both menus when the document is ready
    $(document).ready(function() {
        initializeMainNavMenu();
        initializePageNavMenu();
    });
</script>

</body>

</html>
